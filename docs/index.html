<!doctype html>
<html>
<head>
  <title>Documentation</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="assets/highlight.css">
  <link rel="stylesheet" href="assets/style.css">
</head>
<body>
  <nav class="nav">
    <section class="nav-content">
        <header>Content:</header>
            <ul>
<li><a href="index.html">Doctor Mark Down</a>
<ul>
<li><a href="lib/backend/index.html">Backend</a>
</li>

<li><a href="lib/bin/index.html">BIN / User input</a>
</li>

<li><a href="lib/frontend/index.html">Frontend</a>
</li>

<li><a href="lib/filesystem/index.html">File System Tools</a>
</li>

<li><a href="template/index.html">Creating Custom Template</a>
</li>
</ul></li>
</ul>
    </section>
  </nav>
  <main class="main">
    <h1 id="doctor-mark-down">Doctor Mark Down</h1>
<p>Markdown to Html compiler for creating simple documentation that scales with your project.
You can browse this document as part of documentation generated by <strong>Doctor Mark Down</strong> itself on its <a href="http://turbomack.github.io/DoctorMarkDown">GitHub Pages</a>.</p>
<h2 id="why-">Why?</h2>
<p>Maintaining documentation is expensive. There are many tools that tries to address this issue out there. Some of them uses different aproaches
some of them are pretty similar and differs only in features, API or implementation. <strong>Doctor Mark Down</strong> is not an alternative to any of these
(or at least I do not know any of tool using the same aproach). To be clear there is no one good way to solve every case.
<strong>You should probably consider if Doctor Mark Down fits your needs before you use it in your project.</strong> The reason I wrote Doctor Mark Down is
that I missed the tool which fits my needs for some of my projects or projects I came across with my coleagues &amp; collaborators.
Documentation should be both accesible (think about easy HTML compilation) and easy to maintain (think about keeping it up to date with your project).</p>
<h3 id="how-is-doctor-mark-down-do-not-works">How is Doctor Mark Down do NOT Works</h3>
<p>The most common solution is generate documentation directly from source files using its comments.
This approach has its advantages and disadvantages. The good thing is that documentation lives directly besides source code it refers to.
It&#39;s easy to track comments updates when implementation changes and also it&#39;s supper easy to automate documentation deploy during release etc.
Another important thing might be that it&#39;s supper easy to access documentation when someone works with source directly.
The down side (or at least I think) is that it&#39;s really hard to know how actual documentation will look like based on source (comments in source code).
Also if you start to adding examples and description in your comments it starts to be quite hard to navigate your actual implementation.
Often comments starts to be even larger than actual code which is not cool. I found it&#39;s usually hard to keep comments up to date especially when
you&#39;re spiking some experimental feature. It&#39;s also hard to update coments afterwards or decide which part of your code needs to be docummented deeply
and which implementation detail doesn&#39;t need to be documented at all. Super annoying thing can be when you for some reason need to switch to different tool
and realise that structure of your comments is not compatible with new approach (new tool expect different structure). Personally I do not comment
my source too much in favour of test/spec suit which descibes API anyway and is proven correct. Anyway still you&#39;ll probably need at least some
solution for documenting public API especially for libraries.</p>
<p>Another approach I came around few times is to use <strong>static site generator</strong> like Jekyll. With this kind of tool the documentation written in
some nice markup language (like mark down) and using some template for HTML export. This is nice because you don&#39;t need to care about some weird parser which
comments generator usually uses. Also creating custom templates is supper familiar and documentation can be updated by non-technical people.
Anyway you lost some of the great features of comment approach has. For example your documentation no longer lives together with your implementation.
Even if they share same repository, usually you need to put all Markdown files in some <code>_posts</code> folder etc. Then you have to think
about both structure of your modules and your documentation. It&#39;s also harder to keep a track of which part of documetation needs to be updated
if some implementation changes. Also links in your documentation does not corespond with structure of your code anymore
and you loose the benefit of easy accessibility for developers working with source directly.</p>
<h3 id="how-is-doctor-mark-down-works">How is Doctor Mark Down Works</h3>
<p><strong>Doctor Mark Down</strong> is not better in any of these categories but it comes with reasonable compromise between both.
Its approch is simple. It <strong>uses markdown files</strong> instead of comments but these files live beside actuall implementation.
Routes of generated html reflect structure of fils so <strong>links works across local copy, Github and generated HTML</strong>.
It lets you easily define custom templates using templating language with your custom CSS and JS.
It offers out of the box <strong>syntax highlighting</strong>. It <strong>lets you decide what is worth documenting and what not</strong>.</p>
<h2 id="instalation">Instalation</h2>
<p>Doctor Mark Down is written in typescript and available via npm as compilated javascript package.</p>
<pre><code class="lang-shell">npm <span class="hljs-keyword">install</span> -g doctor-mark-down
</code></pre>
<p>You can also use library level version if you want and use public APIs in your projects:</p>
<pre><code class="lang-shell">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save doctor-mark-down</span>
</code></pre>
<h2 id="usage">Usage</h2>
<p>If you have doctor-mark-down globaly instaled, you should be able to run this command from terminal.</p>
<pre><code class="lang-shell">docmd <span class="hljs-string">[options]</span>
</code></pre>
<h2 id="options">Options</h2>
<p>All options are optional. Anyway you should use them to overwrite default values. Here is list of available options</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Shortcut</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--recursive</code></td>
<td><code>-r</code></td>
<td><code>off</code></td>
<td>Recursive mode</td>
</tr>
<tr>
<td><code>--files</code></td>
<td><code>-f</code></td>
<td><code>[&quot;README.md&quot;]</code></td>
<td>List of source files</td>
</tr>
<tr>
<td><code>--skip-first-headline</code></td>
<td><code>-s</code></td>
<td><code>false</code></td>
<td>Skip first headline in menu tree (only for non recursive)</td>
</tr>
<tr>
<td><code>--out-folder</code></td>
<td><code>-o</code></td>
<td><code>&quot;docs&quot;</code></td>
<td>Compiled files will be stored to this folder</td>
</tr>
<tr>
<td><code>--depth</code></td>
<td><code>-d</code></td>
<td><code>6</code></td>
<td>Depth limit of navigation tree (only for non recursive)</td>
</tr>
<tr>
<td><code>--template</code></td>
<td><code>-t</code></td>
<td><code>default</code></td>
<td>Path to template</td>
</tr>
<tr>
<td><code>--ignore</code></td>
<td><code>-i</code></td>
<td><code>node_modules .git documentation, bower_components</code></td>
<td>Ignored directories</td>
</tr>
</tbody>
</table>
<p>For explanation of how recursive and basic mode <a href="lib/filesystem">here</a>
You can find complete guide for templating <a href="template">here</a></p>
<h1 id="state-of-art">State of Art</h1>
<p><strong>Please be aware that this package is in state of Experiment/Proof of concept stage.
This means API can or can&#39;t change heavilly over time. There is no guarantees that this software will hit stable release
or will be maintain for long time. If you found this project interesting please consider any contribution to make stable release happen.</strong></p>
<h1 id="contributing">Contributing</h1>
<p>All sorts of contributions are wellcome. You fork or clone this repository.</p>
<p>Most of the tasks are already automated using npm scripts.</p>
<h2 id="dependencies">Dependencies</h2>
<p>Node.js should be the only requirement. Anyway this was not tested using Windows.
If you ran into some troubles feel free to open issue.</p>
<h3 id="install-dependencies">Install dependencies</h3>
<pre><code class="lang-shell">npm <span class="hljs-keyword">install</span>
</code></pre>
<h2 id="running-tests">Running Tests</h2>
<p>Jasmine test framework is used. The most important parts are tested. There are still few things that can be test more deeply.
Anyway Typescript provides some extra safety over JavaScript so there is not need to write any large integration tests.
If you plan to contribute to this repository always think about providing PR with tests case by case.
Its usually good to have at least one test per PR if you fixing bug or providing new feature.</p>
<pre><code class="lang-shell">npm <span class="hljs-built_in">test</span>
</code></pre>
<h2 id="build-project">Build project</h2>
<p>Source is written in typescript. You can comple javascript running <code>build</code> command as follows:</p>
<pre><code class="lang-shell">npm <span class="hljs-built_in">run</span> build
</code></pre>
<p>This will egenerate <code>dist</code> folder containing whole project files. This folder is ignored by git.
This step is required if you want to execute <code>./bin/docmd</code>.</p>
<h3 id="docmd-doctor-mark-down">DOCMD Doctor Mark Down</h3>
<p>You can compile Doctor Mark Down documentation for Doctor markdow itsef. This will build project (same as running <code>npm run build</code>)
and use builded <code>bin/docmd</code> for generating documentation:</p>
<pre><code class="lang-shell"><span class="hljs-built_in">npm</span> start
</code></pre>
<h2 id="improvements-i-can-think-of-">Improvements I Can Think of...</h2>
<ul>
<li>[ ] Assets support<ul>
<li>[ ] Custom parser for links</li>
<li>[ ] Linked assets copying</li>
</ul>
</li>
<li>[ ] Improve links parsing<ul>
<li>[ ] Link <code>/index.html</code> to make links work without server</li>
</ul>
</li>
<li>[ ] Passing start path within cmd line (like <code>docmd ~/somewhere</code>)</li>
<li>[ ] Configuration file<ul>
<li>[ ] Fs (levels up) looker for config file</li>
<li>[ ] Load options from config file (<code>.docmd.rc</code> / <code>docmd.json</code>...)</li>
<li>[ ] Custom footers/names and other meta (loaded from)</li>
</ul>
</li>
<li>[ ] Pass datastructure instead of HTML to navigation and menu<ul>
<li>[ ] Some recursive <code>menu-item</code> helper?</li>
<li>[ ] Add state to manu item (<code>acessor</code> &amp; <code>active</code> flags)</li>
</ul>
</li>
</ul>
<p>MIT License</p>
<p>Copyright (c) 2016 Marek Fajkus</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>

  </main>
</body>
</html>
