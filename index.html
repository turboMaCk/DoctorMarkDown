<!doctype html>
<html>
<head>
  <title>Documentation</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="assets/highlight.css">
  <link rel="stylesheet" href="assets/style.css">
</head>
<body>
  <nav class="nav">
    <section class="nav-content">
        <header>Content:</header>
            <ul>
<li><a href="index.html">Doctor Mark Down</a>
<ul>
<li><a href="template/index.html">Creating Custom Template</a>
</li>

<li><a href="lib/backend/index.html">Backend</a>
</li>

<li><a href="lib/bin/index.html">BIN / User input</a>
</li>

<li><a href="lib/filesystem/index.html">File System Tools</a>
</li>

<li><a href="lib/frontend/index.html">Frontend</a>
</li>
</ul></li>
</ul>
    </section>
  </nav>
  <main class="main">
    <h1 id="doctor-mark-down">Doctor Mark Down</h1>
<p>Markdown to Html compiler for creating simple documentation that scales with your project.
You can browse this document as part of documentation generated by <strong>Doctor Mark Down</strong> itself on its <a href="http://turbomack.github.io/DoctorMarkDown">GitHub Pages</a>.</p>
<h2 id="why-">Why?</h2>
<p>Maintaining documentation is expensive. There are many tools that tries to address this issue out there. Some of them uses different aproaches
some of them are pretty similar and differs only in features, API or implementation. <strong>Doctor Mark Down</strong> is not an alternative to any of these
(or at least I do not know any of tool using the same aproach). To be clear there is no one good way to solve every cases.
<strong>You should probably consider if Doctor Mark Down fits your needs before you use it in your project.</strong> The reason I wrote Docktor Mark Down is
that I missed the tool which fits my needs for some of my projects or projects I came across with my coleagues and so on.
Documentation should be both accesible (think about public HTML version) and easy to maintain.</p>
<h3 id="how-is-docktor-mark-down-different">How is Docktor Mark Down different</h3>
<p>The most common solution is generate documentation directly from source files using its comments.
This approach has its advantages and disadvantages. The good thing is that documentation lives directly besides source code it refers to.
It&#39;s easy to track comments updates when implementation changes and also it&#39;s supper easy to automate documentation deploy during release etc.
Another important thing might be that it&#39;s supper easy to access documentation when someone works with source directly.
The down side (or at least I think) is that it&#39;s really hard to know how actual documentation will look like based on source.
Also if you start to adding examples and description in your comments it starts to be quite hard to navigate your actual implementation.
Often comments starts to be even larger than actual code which is not cool. I found it&#39;s usually hard to keep comments up to date especially when
you&#39;re spiking some experimental feature. It&#39;s also hard to update coments afterwards or decide which part of your code needs to be docummented deeply
and which implementation detail will be better to leave from documentation at all. Super annoying thing can be when you try to move from
one solution to another for somereason and realise that structure of your comments is not compatible with new approach. Personally I do not comment
my source much and prefering to keep simple test/spec suit for internal documentation. Anyway still you&#39;ll probably need at least some
solution for documenting public API where tests are odd solution</p>
<p>Another approach I came around few times is to use <strong>static site generator</strong> like Jekyll. With this you have documentation written in
some nice markup language like mark down and some template. This is nice because you don&#39;t need to care about some weird parser which
comments generator usually uses. Also creating custom templates is supper familiar and documentation can be updated by non-technical people.
Anyway you lost some of the great features comment approach has. For example your documentation no longer lives together with your implementation.
Even if they share same repository, usually you need to put all Markdown files in some <code>_posts</code> folder etc. Then you have to think
about both structure of your modules and your documentation. It&#39;s also harder to keep a track which part of documetation needs to be updated
if some implementation changes. Also link in your documentation does not corespond with structure of your code base and documentation
itselves is not much helpfull for people working with source directly.</p>
<p><strong>Docktor Mark Down</strong> is not better in any of these categories but it comes with reasonable compromise between both.
Its approcha is simple. It <strong>uses markdown files</strong> instead of comments but these files live beside actuall implementation.
Routes of generated html corespond with file system structure so <strong>links works across local copy, Github and generated HTML</strong>.
It lets you easily define custom templates using templating language with your custom CSS and JS.
It offers out of the box <strong>syntax highlighting</strong>. It <strong>lets you decide what is worth documenting and what not</strong>.</p>
<h2 id="instalation">Instalation</h2>
<p>Docktor Mark Down is written in typescript and available via npm as compilated javascript package.</p>
<pre><code class="lang-shell">npm <span class="hljs-keyword">install</span> -g docktor-mark-down
</code></pre>
<p>You can also use library level version if you want and use public APIs in your projects:</p>
<pre><code class="lang-shell">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save docktor-mark-down</span>
</code></pre>
<h2 id="settings">Settings</h2>
<p>All settings are optional. Anyway you should use them to overwrite default values. Here is list of available options</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Shortcut</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--recursive</code></td>
<td><code>-r</code></td>
<td><code>off</code></td>
<td>Recursive mode</td>
</tr>
<tr>
<td><code>--files</code></td>
<td><code>-f</code></td>
<td><code>[&quot;README.md&quot;]</code></td>
<td>List of source files</td>
</tr>
<tr>
<td><code>--skip-first-headline</code></td>
<td><code>-s</code></td>
<td><code>false</code></td>
<td>Skip first headline in menu tree (only for non recursive)</td>
</tr>
<tr>
<td><code>--out-folder</code></td>
<td><code>-o</code></td>
<td><code>&quot;documentation&quot;</code></td>
<td>Compiled files will be stored to this folder</td>
</tr>
<tr>
<td><code>--depth</code></td>
<td><code>-d</code></td>
<td><code>6</code></td>
<td>Depth limit of navigation tree (only for non recursive)</td>
</tr>
<tr>
<td><code>--template</code></td>
<td><code>-t</code></td>
<td><code>default</code></td>
<td>Path to template</td>
</tr>
<tr>
<td><code>--ignore</code></td>
<td><code>-i</code></td>
<td><code>node_modules .git documentation, bower_components</code></td>
<td>Ignored directories</td>
</tr>
</tbody>
</table>
<p>You can find instructions for template creation <a href="template">here</a></p>
<h1 id="contributing">Contributing</h1>
<p>All sorts of contributions are wellcome. You fork or clone this repository.</p>
<p>Most of the tasks are already automated using npm scripts.</p>
<h2 id="dependencies">Dependencies</h2>
<p>Node.js should be the only requirement. Anyway this was not tested using Windows.
If you ran into some troubles feel free to open issue.</p>
<h3 id="install-dependencies">Install dependencies</h3>
<pre><code class="lang-shell">npm <span class="hljs-keyword">install</span>
</code></pre>
<h2 id="running-tests">Running Tests</h2>
<p>Jasmine test framework is used. The most important parts are tested. There are still few things that can be test more deeply.
Anyway Typescript provides some extra safety over JavaScript so there is not need to write any large integration tests.
If you plan to contribute to this repository always think about providing PR with tests case by case.
Its usually good to have at least one test per PR if you fixing bug or providing new feature.</p>
<pre><code class="lang-shell">npm <span class="hljs-built_in">test</span>
</code></pre>
<h2 id="build-project">Build project</h2>
<p>Source is written in typescript. You can comple javascript running <code>build</code> command as follows:</p>
<pre><code class="lang-shell">npm <span class="hljs-built_in">run</span> build
</code></pre>
<p>This will egenerate <code>dist</code> folder containing whole project files. This folder is ignored by git.
This step is required if you want to execute <code>./bin/docmd</code>.</p>
<h3 id="docmd-docktor-mark-down">DOCMD Docktor Mark Down</h3>
<p>You can compile Docktor Mark Down documentation for Docktor markdow itsef. This will build project (same as running <code>npm run build</code>)
and use builded <code>bin/docmd</code> for generating documentation:</p>
<pre><code class="lang-shell"><span class="hljs-built_in">npm</span> start
</code></pre>

  </main>
</body>
</html>
